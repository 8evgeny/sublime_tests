Тест "Радар"


1. Создать CMake — проект. Стандарт C++ - 11 или 14.
Дополнительные библиотеки : OpenCV (3 или 4), libglm.


2. Создать класс, инкапсулирующий источник времени для приложения.

Интерфейс класса:

class SystemClock
{
public:
        static int64_t get_time_milliseconds();
};


3. Создать класс CThread, инкапсулирующий стандартный поток C++.

Интерфейс класса:

class CThread
{
public:
        CThread(const CThread&) = delete;
        CThread(CThread&&) = delete;
        CThread & operator = (const CThread&) = delete;
        CThread & operator = (CThread&&) = delete;
public:
        explicit CThread();
        virtual ~CThread();
public:
        virtual void run();
        virtual void stop();
        virtual void join();
        virtual void set_iteration_period_milliseconds(const int64_t period);
        virtual void set_iteration_callback(const std::function<void()> & on_iteration_callback);
private:
        void shutdown();
private:
        std::atomic_bool stop_flag {false};
        int64_t period_ms = 20;
        std::shared_ptr<std::thread> thread = nullptr;
        std::function<void()> on_iteration_callback = nullptr;
};


Обратить внимание на стиль оформления класса. В дальнейшем придерживаться данного стиля. Стиль скобок функций и методов классов:

void function()
{
}
Обратить внимание на использование пробелов с операторами. Имена методов и переменных должны корректно отражать их назначение, для облегчения чтения кода и поиска ошибок.

Использование идиомы pimpl не требуется.

Деструктор должен корректно останавливать работающий поток, не генерировать исключения.

Метод run() - неблокирующий, запускает внутренний поток. При невозможности корректно запустить поток, генерирует исключение. При нормальном запуске потока возвращает управление вызвавшему коду.

Метод stop() - неблокирующий, потокобезопасный. Сигнализирует объекту о необходимости завершить работу внутреннего потока, без фактического ожидания остановки.

Метод join() предназначен для ожидания фактического завершения работы потока после подачи сигнала остановки вызовом stop().

Метод set_iteration_period_milliseconds(const int64_t period) задает период вызова внешней callback — функции, в миллисекундах.

Метод set_iteration_callback(const std::function<void()> & on_iteration_callback) задает callback — функциию, которую объект будет вызывать каждые period миллисекунд.

Например, period равен 50 миллисекундам. Если  on_iteration_callback выполнил свою работу за 1 миллисекунду, следующий вызов  on_iteration_callback произойдет через 49 миллисекунд. Если  on_iteration_callback выполнил свою работу за 30 миллисекунд, следующий вызов  on_iteration_callback произойдет через 20 миллисекунд. Если  on_iteration_callback выполнил свою работу за 60 миллисекунд, следующий вызов  on_iteration_callback произойдет немедленно, без паузы. Высокая точность не требуется, желаемый период задается примерно, фактически интервалы вызовов зависят от работы планировщика ядра ОС, пытаться обеспечить точность не нужно.

Жизненный цикл объекта:

СThread thread;
thread.set_iteration_period_milliseconds(50);
thread.set_iteration_callback(callback);
thread.run();

……

Из этого же, или из другого потока может быть вызван stop()

……

Этот же поток:
thread.stop();
thread.join();
4. Создать базовый класс для сообщения радара.

class RadarMessage
{
public:
        explicit RadarMessage();
        virtual ~RadarMessage();
public:
        virtual bool is_data_valid() const = 0;
public:
        int64_t radar_id = 0;
};

Метод is_data_valid() проверяет, содержит ли объект валидные данные.
Поле  radar_id содержит уникальный идентификатор радара — источника сообщения.

5. Создать базовый класс радара.
class Radar
{
public:
        Radar(const Radar&) = delete;
        Radar(Radar&&) = delete;
        Radar & operator = (const Radar&) = delete;
        Radar & operator = (Radar&&) = delete;
public:
        explicit Radar();
        virtual ~Radar();
public:
        virtual void run();
        virtual void stop();
        virtual void wait_shutdown();
        virtual void set_radar_id(const int64_t id);
        virtual void set_data_connector(const RadarDataConnector & data_connector);
protected:
        virtual RadarDataConnector get_data_connector() const;
        virtual void internal_thread_iteration() = 0;
        virtual int64_t get_radar_id() const;
private:
        CThread thread;
        bool is_runned_flag = false;
        RadarDataConnector data_connector = nullptr;
        int64_t radar_id = 0;
};

Базовый класс обеспечивает функционирование внутреннего потока, вызов переопределенного в потомке метода итерации потока.
Деструктор корректно останавливает внутренний поток. Деструктор должен быть защищен от генерации исключений.
Обратить внимание на идеологию перехвата исключений во внутреннем потоке — все исключения во внутреннем потоке не должны покидать его.
Метод run() неблокирующий, запускает работу внутреннего потока. Требования к исключениям аналогичны классу потока.
Метод stop() сигнализирует о необходимости завершить работу внутреннего потока. Неблокирующий, потокобезопасный.
Метод wait_shutdown() ожидает завершения работы внутреннего потока (аналог метода join() класса потока).

Метод set_radar_id(const int64_t id) задает уникальный идентификатор экземпляра радара.

Метод set_data_connector(const RadarDataConnector & data_connector) задает примник сообщений радара.
Класс должен агрегировать экземпляр класса  CThread.
6. Создать класс сообщения берегового радара, унаследованный от сообщения радара.
class CoastalRadarMessage : public RadarMessage
{
public:
        explicit CoastalRadarMessage();
        virtual ~CoastalRadarMessage() override;
public:
        virtual bool is_data_valid() const override;
        struct
        {
                double x = 0;
                double y = 0;
                double z = 0;
                double sx = 0;
                double sy = 0;
                double sz = 0;
                double size = 0;
                int64_t timestamp = 0;
        } data;
};

Данные включают в себя координаты, вектор скорости (компоненты по осям), размер объекта, и отметку времени сообщения, в миллисекундах.
7. Создать класс берегового радара, унаследованный от класса радара. Переопределить метод internal_thread_iteration(). В классе реализовать следующую логику: каждые 100 мс радар посылает приемнику сообщение с координатами, размером объекта, вектором скорости и отметкой времени. Обратить внимание на потокобезопасность при передаче сообщения. Объект, данные которого передаются радаром, должен совершать эволюции в пространстве — перемещаться по какой-нибудь траектории в пределах куба размерами 100 х 100 х 100 м.

8. Создать класс RadarDisplay, выполняющий функцию приема данных радара (произвольного разумного количества радаров), и отображающий объекты.

Класс должен обеспечивать асинхронную работу во внутреннем потоке. В качестве внутреннего потока агрегировать объект класса CThread. Класс должен обеспечивать интерфейс:

        virtual void run();
        virtual void stop();
        virtual void wait_shutdown();
        virtual void accept_radar_message(const std::shared_ptr<RadarMessage> & message);

Методы run(), stop(), wait_shutdown() - аналогичны вышеописанным.

Метод accept_radar_message(const std::shared_ptr<RadarMessage> & message) принимает сообщение от радара, должен обеспечивать потокобезопасность, и помещать сообщение во внутреннюю очередь. Может вызываться произвольным коичеством радаров (несколько радаров могут передавать данные одному дисплею).

Объект класса  RadarDisplay должен отображать на рабочем столе окно (можно использовать imshow() из OpenCV), на котором отображать положение каждого объекта, вектор скорости, и идентификатор радара, которому принадлежат данные об объекте. В зависимости от признака валидности можно использовать цветовую кодировку: зеленый объект, если данные валидны; красный — если не валидны.
Так же следует отображать разными цветами три небольших вектора, исходящие из центра объекта, направленные коллинеарно осям x, y, z в мировом пространстве.

Картинка должна отображать перспективный вид с камеры, расположенной в некоторой произвольной точке пространства (точка расположения камеры выбирается самостоятельно исходя из адекватности получаемого изображения, например, в месте расположения радара (-ов)).
Преобразование координат объектов и векторов из мирового пространства в перспективное изображение в плоскости матрицы камеры выполняется стандартным методом — с помощью матриц проекции и вида. Использовать готовую библиотеку libglm.
http://www.opengl-tutorial.org/ru/beginners-tutorials/tutorial-3-matrices/

9. Собрать из классов демонстрационное приложение, в котором использовать 2-3 радара и один дисплей, отображающий перемещение объектов, данные о которых передаются радарами.

10. Планируемая сложность — 6-8 часов, при наличии базовых знаний по использованным темам.

Оцениваются:
– Способность к интерпретации задачи;
– Способность разбираться в новой тематике;
– Способность ориентироваться в сложной архитектуре;
– Чистота и читаемость кода, стиль именования переменных и методов;
– Внимание к исключительным ситуациям, в которых могут возникать ошибки; контроль за использованием ресурсов.
