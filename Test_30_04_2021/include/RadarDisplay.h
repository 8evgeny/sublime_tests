#pragma once
#include "CThread.h"
#include "RadarMessage.h"
#include "main.h"

class RadarDisplay {
public:
    virtual void run();
    virtual void stop();
    virtual void wait_shutdown();
    virtual void accept_radar_message(const std::shared_ptr<RadarMessage>& message);

private:
    CThread thread;
    bool is_display_flag = false;
};

/*
8. Создать класс RadarDisplay, выполняющий функцию приема данных радара
(произвольного разумного количества радаров), и отображающий объекты.

Класс должен обеспечивать асинхронную работу во внутреннем потоке.
В качестве внутреннего потока агрегировать объект класса CThread.

Класс должен обеспечивать интерфейс:
virtual void run();
virtual void stop();
virtual void wait_shutdown();
virtual void accept_radar_message(const std::shared_ptr<RadarMessage> & message);

Методы run(), stop(), wait_shutdown() - аналогичны вышеописанным.

Метод accept_radar_message(const std::shared_ptr<RadarMessage> & message)
принимает сообщение от радара, должен обеспечивать потокобезопасность, и
помещать сообщение во внутреннюю очередь.
Может вызываться произвольным коичеством радаров
(несколько радаров могут передавать данные одному дисплею).

Объект класса  RadarDisplay должен отображать на рабочем столе окно
(можно использовать imshow() из OpenCV), на котором отображать
положение каждого объекта, вектор скорости, и идентификатор радара,
которому принадлежат данные об объекте. В зависимости от признака валидности можно
использовать цветовую кодировку: зеленый объект, если данные валидны; красный — если не валидны.
Также следует отображать разными цветами три небольших вектора, исходящие из центра объекта,
направленные коллинеарно осям x, y, z в мировом пространстве.

Картинка должна отображать перспективный вид с камеры, расположенной в некоторой
произвольной точке пространства (точка расположения камеры выбирается самостоятельно
исходя из адекватности получаемого изображения, например, в месте расположения радара (-ов)).

Преобразование координат объектов и векторов из мирового пространства в перспективное изображение
в плоскости матрицы камеры выполняется стандартным методом — с помощью матриц проекции и вида.
Использовать готовую библиотеку libglm.
http://www.opengl-tutorial.org/ru/beginners-tutorials/tutorial-3-matrices/
*/
