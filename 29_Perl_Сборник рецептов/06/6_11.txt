Пример 6.11. tcgrep
#!/usr/bin/perl -w
# tcgrep: версия grep, написанная Томом Кристиансеном
# версия 1.0: 30 сентября 1993 года
# версия 1.1: 1 октября 1993 года
# версия 1.2: 26 июля 1996 года
# версия 1.3: 30 августа 1997 года
# версия 1.4: 18 мая 1998 года

use strict;
                                  # Глобальные переменные
our ($Me, $Errors, $Grand_Total, $Mult, %Compress, $Matches);
my ($matcher, $opt);              # matcher – анонимная функция
                                  # для поиска совпадений
                                  # opt – ссылка на хэш, содержащий
                                  # параметры командной строки
init();                           # Инициализировать глобальные переменные
($opt, $matcher) = parse_args();  # Получить параметры командной строки
                                  # и шаблоны
matchfile($opt, $matcher, @ARGV); # Обработать файлы
exit(2) if $Errors;
exit(0) if $Grand_Total;
exit(1);
###################################
sub init {
    ($Me = $0) =~ s!.*/!!;        # Получить базовое имя программы, "tcgrep"
    $Errors = $Grand_Total = 0;   # Инициализировать глобальные счетчики
    $Mult = "";                   # Флаг для нескольких файлов в @ARGV
    $| = 1;                       # Автоматическая очистка выходного буфера
    %Compress = (                 # Расширения и имена программ
        z  => 'gzcat',            # для распаковки
        gz => 'gzcat',
        Z  => 'zcat',
    );
}
###################################
sub usage {
        die <<EOF
usage: $Me [flags] [files]
Standard grep options:
        i   case insensitive
        n   number lines
        c   give count of lines matching
        C   ditto, but >1 match per line possible
        w   word boundaries only
        s   silent mode
        x   exact matches only
        v   invert search sense (lines that DON'T match)
        h   hide filenames
        e   expression (for exprs beginning with -)
        f   file with expressions
        l   list filenames matching
Specials:
        1   1 match per file
        H   highlight matches
        u   underline matches
        r   recursive on directories or dot if none
        t   process directories in ’ls -t’ order
        p   paragraph mode (default: line mode)
        P   ditto, but specify separator, e.g. -P ’%%\\n’
        a   all files, not just plain text files
        q   quiet about failed file and dir opens
        T   trace files as opened
May use a TCGREP environment variable to set default options.
EOF
}
###################################
sub parse_args {
    use Getopt::Std;
    my ($optstring, $zeros, $nulls, %opt, $pattern, @patterns, $match_code);
    my ($SO, $SE);
    if (my $opts = $ENV{TCGREP}) { # Получить переменную окружения TCGREP
        $opts =~ s/^([^\-])/-$1/;  # Если начальный – отсутствует, добавить
        unshift(@ARGV, $opts);        # Включить строку TCGREP в @ARGV
    }
    $optstring = "incCwsxvhe:f:l1HurtpP:aqT";
    $zeros = 'inCwxvhelut';       # Параметры, инициализируемые 0
                                  # (для отмены предупреждений)
    $nulls = 'pP';                # Параметры, инициализируемые ""
                                  # (для отмены предупреждений)
    @opt{ split //, $zeros } = ( 0 )  x length($zeros);
    @opt{ split //, $nulls } = ( '' ) x length($nulls);
    getopts($optstring, \%opt)              or usage();
    if ($opt{f}) {                # -f файл с шаблонами
        open(PATFILE, $opt{f}) or die qq($Me: Can't open '$opt{f}': $!);
                                  # Проверить каждый шаблон в файле
        while ( defined($pattern = <PATFILE>) ) {
            chomp $pattern;
            eval { 'foo' =~ /$pattern/, 1 } or
                die "$Me: $opt{f}:$.: bad pattern: $@";
            push @patterns, $pattern;
        }
        close PATFILE;
    }
    else {                        # Проверить шаблон
        $pattern = $opt{e} || shift(@ARGV) || usage();
        eval { 'foo' =~ /$pattern/; 1 } or
            die "$Me: bad pattern: $@";
        @patterns = ($pattern);
    }
    # -H - выделить цветом, -u - подчеркнуть
    if ($opt{H} || $opt{u}) {
        my $term = $ENV{TERM} || 'vt100';
        my $terminal;
        eval {                    # Попытаться найти служебные
                                  # последовательности для выделения
            require POSIX;        # или подчеркнуть через Term::Cap
            use Term::Cap;

   my $termios = POSIX::Termios->new();
            $termios->getattr;
            my $ospeed = $termios->getospeed;
            $terminal = Tgetent Term::Cap { TERM=>undef, OSPEED=>$ospeed }
        };
        unless ($@) {             # Если успешно, получить служебные
                                  # последовательности для выделения (-H)
            local $^W = 0;        # или подчеркивания (-u)
            ($SO, $SE) = $opt{H}
                ? ($terminal->Tputs('so'), $terminal->Tputs(’se’))
                : ($terminal->Tputs('us'), $terminal->Tputs(’ue’));
        }
        else {                    # Если попытка использования Term::Cap
                                  # заканчивается неудачей, получить
            ($SO, $SE) = $opt{H}  # служебные последовательности
                                  # командой tput
                ? (`tput -T $term smso`, `tput -T $term rmso`)
                : (`tput -T $term smul`, `tput -T $term rmul`)
        }
    }
    # -i - поиск без учета регистра символов
    if ($opt{i}) {
        @patterns = map {"(?i)$_"} @patterns;
    }
    # -p или -P - абзацный режим, добавить /m
    if ($opt{p} || $opt{P}) {
        @patterns = map {"(?m)$_"} @patterns;
    }
    # Стандартный абзацный режим
    $opt{p}   && ($/ = '');
    # Пользовательский абзацный режим
    $opt{P}   && ($/ = eval(qq("$opt{P}")));     # for -P ’%%\n’
    # -w - только по границам слова (XXX: всегда ли это оптимально?)
    $opt{w}   && (@patterns = map {’\b’ . $_ . ’\b’} @patterns);
    # -x - только для полных строк
    $opt{'x'} && (@patterns = map {"^$_\$"} @patterns);
    # Проверить, нужно ли выводить имя файла перед каждым совпадением
    if (@ARGV) {
        $Mult = 1 if ($opt{r} || (@ARGV > 1) || -d $ARGV[0]) && !$opt{h};
    }
    # Если пользователь хочет просто получить список файлов,
    # прервать поиск после первого совпадения
    $opt{1}   += $opt{l};                   # Единица и буква l
    $opt{H}   += $opt{u};
    $opt{c}   += $opt{C};
    $opt{'s'} += $opt{c};
    # Прервать при первом совпадении, если ведется проверка без подсчета
    $opt{1}   += $opt{'s'} && !$opt{c};     # Единица
    # Аргументы по умолчанию: cwd при рекурсии, stdin без нее
    @ARGV = ($opt{r} ? ’.’ : ’-’) unless @ARGV;
    $opt{r} = 1 if !$opt{r} && grep(-d, @ARGV) == @ARGV;
    ######
    # Начинается самое трудное: построение функции в текстовом виде 
    # для последующей передачи eval.
    #
    $match_code  = '';
    $match_code .= 'study;' if @patterns > 5; # Может немного 
                                              # ускорить работу
    foreach (@patterns) { s(/)(\\/)g }
    # Добавление начальной и конечной последовательностей для выделения
    if ($opt{H}) {
        foreach $pattern (@patterns) {
            $match_code .= "\$Matches += s/($pattern)/${SO}\$1${SE}/g;";
        }
    }
    # Ключ -v - подсчет НЕСОВПАДАЮЩИХ строк
    elsif ($opt{v}) {
        foreach $pattern (@patterns) {
            $match_code .= "\$Matches += !/$pattern/;";
        }
    }
    # Полный подсчет с несколькими совпадениями в строке
    elsif ($opt{C}) {
        foreach $pattern (@patterns) {
            $match_code .= "\$Matches++ while /$pattern/g;";
        }
    }
    else {
        foreach $pattern (@patterns) {
            $match_code .= "\$Matches++ if /$pattern/;";
        }
    }
    # Откомпилировать как замыкание и получить указатель на функцию.
    $matcher = eval "sub { $match_code }";
    die if $@;
    return (\%opt, $matcher);
}
###################################
sub matchfile {
    $opt = shift;                 # Ссылка на хэш параметров
    $matcher = shift;             # Ссылка на функцию поиска совпадений
    my ($file, @list, $total, $name);
    local($_);
    $total = 0;
FILE: while (defined ($file = shift(@_))) {
        if (-d $file) {
            if (-l $file && @ARGV != 1) {
                warn "$Me: \"$file\" is a symlink to a directory\n"
                    if $opt->{T};
                next FILE;
            }
            if (!$opt->{r}) {
                warn "$Me: \"$file\" is a directory, but no -r given\n"
                    if $opt->{T};
                next FILE;
            }

  unless (opendir(DIR, $file)) {
                unless ($opt->{'q'}) {
                    warn "$Me: can't opendir $file: $!\n";
                    $Errors++;
                }
                next FILE;
            }
            @list = ();
            for (readdir(DIR)) {
                push(@list, "$file/$_") unless /^\.{1,2}$/;
            }
            closedir(DIR);
            # Ключ -t - сортировка по времени (от новых к старым)
            # Использование алгоритма из рецепта 4.16, 
            # "Сортировка списка по вычисляемому полю"
            if ($opt->{t}) {
                @list = map  { $_->[0] }
                        sort { $a->[1]<=>$b->[1] }
                        map  { [ $_, -M $_ ] } @list;
            }
            else {
                @list = sort @list;
            }
            matchfile($opt, $matcher, @list);    # Обработка файлов
            next FILE;
        }
        # Предотвратить досадную ситуацию, когда grep хочет
        # получить ввод с клавиатуры, а пользователь этого не понимает.
        if ($file eq '-') {
            warn "$Me: reading from stdin\n" if -t STDIN && !$opt->{'q'};
            $name = '<STDIN>';
        }
        else {
            $name = $file;
            unless (-e $file) {
                warn qq($Me: file "$file" does not exist\n)
                    unless $opt->{’q’};
                $Errors++;
                next FILE;
            }
            unless (-f $file || $opt->{a}) {
                warn qq($Me: skipping non-plain file "$file"\n) 
                    if $opt->{T};
                next FILE;
            }
            # Также можно было использовать File::Spec
            my ($ext) = $file =~ /\.([^.]+)$/;
            # Проверить, известно ли, как для данного расширения
            # преобразовать данные в обычный текст при помощи фильтра.
            if (defined $ext && exists $Compress{$ext}) {
                $file = "$Compress{$ext} <$file |";
            }
            elsif (! (-T $file  || $opt->{a})) {
                warn qq($Me: skipping binary file "$file"\n) if $opt->{T};
                next FILE;
            }
        }
        warn "$Me: checking $file\n" if $opt->{T};
        unless (open(FILE, $file)) {
            unless ($opt->{’q’}) {
                warn "$Me: $file: $!\n";
                $Errors++;
            }
            next FILE;
        }
        $total = 0;
        $Matches = 0;
LINE:  while (<FILE>) {
            $Matches = 0;
            ##############
            &{$matcher}();        # Поиск совпадений
            ##############
            next LINE unless $Matches;
            $total += $Matches;
            if ($opt->{p} || $opt->{P}) {
                s/\n{2,}$/\n/ if $opt->{p};
                chomp         if $opt->{P};
            }
            print("$name\n"), next FILE if $opt->{l};
            # Следующий закомментированный блок
            # содержит расширенную (и более понятную)
            # версию команды, следующей за ним.
            # Это один из тех случаев, когда мы жертвуем
            # наглядностью ради скорости: команда print()
            # выполняется только один раз вместо четырех, 
            # а блок в фигурных скобках не используется
            # (обратите внимание: для работы этого фрагмента
            # переменная $Mult должна быть равна "", а не 0).
            ########
            ## unless ($opt->{'s'}) {
            ##    print "$name:"              if $Mult;
            ##    print "$.:"                 if $opt{n};
            ##    print;
            ##    print (('-' x 20) . "\n")   if $opt->{p} || $opt->{P};
            ## } 
            ########
            $opt->{'s'} || print $Mult && "$name:",
                $opt->{n} ? "$.:" : "",
                $_,
                ($opt->{p} || $opt->{P}) && (’-’ x 20) . "\n";
            next FILE if $opt->{1};                 # Единица
        }
    }
    continue {
            print $Mult && "$name:", $total, "\n" if $opt->{c};
    }
    $Grand_Total += $total;
}

