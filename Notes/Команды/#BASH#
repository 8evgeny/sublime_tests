break выход из цикла for, while или until
continue выполнение следующей итерации цикла for, while или until
echo вывод аргументов, разделенных пробелами, на стандартное устройство вывода
exit выход из оболочки
export отмечает аргументы как переменные для передачи в дочерние процессы в среде
hash запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении
kill посылает сигнал завершения процессу
pwd выводит текущий рабочий каталог
read читает строку из ввода оболочки и использует ее для присвоения значений указанным переменным.\
return заставляет функцию оболочки выйти с указанным значением
shift перемещает позиционные параметры налево
test вычисляет условное выражение
times выводит имя пользователя и системное время, использованное оболочкой и ее потомками
trap указывает команды, которые должны выполняться при получении оболочкой сигнала
unset вызывает уничтожение переменных оболочки
wait ждет выхода из дочернего процесса и сообщает выходное состояние.


$DIRSTACK - содержимое вершины стека каталогов
$EDITOR - текстовый редактор по умолчанию
$EUID - Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...
$UID - ...содержит реальный идентификатор, который устанавливается только при логине.
$FUNCNAME - имя текущей функции в скрипте.
$GROUPS - массив групп к которым принадлежит текущий пользователь
$HOME - домашний каталог пользователя
$HOSTNAME - ваш hostname
$HOSTTYPE - архитектура машины.
$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов
$OLDPWD - прежний рабочий каталог
$OSTYPE - тип ОС
$PATH - путь поиска программ
$PPID - идентификатор родительского процесса
$SECONDS - время работы скрипта(в сек.)
$# - общее количество параметров переданных скрипту
$* - все аргументы переданыне скрипту(выводятся в строку)
$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик
$! - PID последнего запущенного в фоне процесса
$$ - PID самого скрипта


if [[ "$source" -eq "$dest" ]] # в ковычках указываем имена переменных для сравнения. -eq - логическое сравнение обозначающие "равны"
then # если они действительно равны, то
echo "Применик $dest и источник $source один и тот же файл!" #выводим сообщение об ошибке, т.к. $source и $dest у нас равны
exit 1 # выходим с ошибкой (1 - код ошибки)
else # если же они не равны
cp $source $dest # то выполняем команду cp: копируем источник в приемник
echo "Удачное копирование!"
fi #обозначаем окончание условия.

В качестве команд возвращающих код возврата могут выступать структуры [[ , [ , test, (( )) или любая другая(или несколько) linux-команда.
test - используется для логического сравнения. после выражения, неоьбходима закрывающая скобка "]"
[ - синоним команды test
[[ - расширенная версия "[" (начиная с версии 2.02)(как в примере), внутри которой могут быть использованы || (или), & (и). Долна иметь закрывающуб скобку "]]"
(( )) - математическое сравнение.

-z # строка пуста
-n # строка не пуста
=, (==) # строки равны
!= # строки неравны
-eq # равно
-ne # неравно
-lt,(< ) # меньше
-le,(<=) # меньше или равно
-gt,(>) #больше
-ge,(>=) #больше или равно
! #отрицание логического выражения
-a,(&&) #логическое «И»
-o,(||) # логическое «ИЛИ»


$# — это счетчик, который показывает, сколько аргументов было использовано при запуске скрипта.
$@ — список всех аргументов, которые использ
условие for i in $@ означает «для каждого аргумента».

https://sgolubev.ru/spietsialnyie-paramietry-bash-s-primierami/
Сейчас пойдет речь о таких параметрах bash как $, $@, $#, $$, $!, $?, $-, $
Для доступа ко всему списку позиционных параметров доступны два специальных параметра $* и $@. За двойными кавычками они оба эквивалентны, оба раскрывают список позиционных параметров, начиная с $1, разделенные пробелами.

В двойных кавычках, однако, они различаются:

$* в паре двойных кавычек эквивалентен списку позиционных параметров, разделенных первым символом IFS "$1C$2c$3...".
$@ в паре двойных кавычек эквивалентен списку позиционных параметров, разделенных пробелами без кавычек, т. е., "$1" "$2".."$Н."

$? Дает статус выхода последней выполненной команды.
$- Параметры, заданные с помощью встроенной команды Set
$_ Дает последний аргумент предыдущей команды. При запуске оболочки выдает абсолютное имя файла скрипта шелла, который выполняется.

trap ДЕЙСТВИЕ СИГНАЛ
Trap работает очень просто: при возникновении сигнала будет выполнено указанное действие. Если действие простое (последовательность команд, умещающаяся на одной строке), его можно указать прямо в аргументе trap. Если не очень простое, то надо объявить функцию и поместить вызов этой функции в trap.

Можно обрабатывать стандартные сигналы (их полный список выводится по trap -l). Также доступны специфические для Bash: DEBUG, RETURN, ERR, EXIT.

На практике trap оказывается не такой уж простой штукой. Дьявол как всегда кроется в деталях. Сейчас покажу.

Приведу небольшой список наиболее часто встречающихся сигналов:
HUP – hangup, отбой;
INT – interrupt, прерывание;
QUIT – выход;
ILL – illegal instruction, программная ошибка;
FPE – floating point exception, вычислительная ошибка;
KILL – убить процесс;
TERM – termination, завершить процесс;
CHILD – завершился дочерний процесс.

Пример:
trap '' INT #игнорировать сигнал INT

Для того, чтобы протоколировать процесс работы своего скрипта, нужно использовать команду tee. Команда копирует данные из своего стандартного потока ввода и раздваивает их на стандартный поток ввода и в указанный файл лога. Для пояснения приведу пример:
$ cat listfile* | sort | tee check.file | uniq > result.file

Увеличение переменной
var=$((var+1))
((var=var+1))
((var+=1))
((var++))
let "var=var+1"
let "var+=1" 
let "var++"

Например проверка строки bash на то, начинается ли она с символа y:

#!/bin/bash
x=yandex
[[ $x == y* ]]
echo $?




arr=()	Создание пустого массива
arr=(1 2 3)	Инициализация массива
${arr[2]}	Получение третьего элемента массива
${arr[@]}	Получение всех элементов массива
${!arr[@]}	Получение индексов массива
${#arr[@]}	Вычисление размера массива
arr[0]=3	Перезапись первого элемента массива
arr+=(4)	Присоединение к массиву значения
str=$(ls)	Сохранение вывода команды ls в виде строки
arr=( $(ls) )	Сохранение вывода команды ls в виде массива имён файлов
${arr[@]:s:n}	Получение элементов массива начиная с элемента с индексом s до элемента с индексом s+(n-1)

handywork < data.in > results.out 2>&1