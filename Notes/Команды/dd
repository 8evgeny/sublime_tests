Начну с небольшого примера, наглядно иллюстрирующего основные параметры команды:

# dd if=/dev/urandom of=/dev/null bs=100M count=5

Параметры:
if: указывает на источник, т.е. на то, откуда копируем. Указывается файл, который может быть как обычным файлом, так и файлом устройства.
of: указывает на файл назначения. То же самое, писать можем как в обычный файл, так и напрямую в устройство.
bs: количество байт, которые будут записаны за раз. Можно представлять этот аргумент как размер куска данные, которые будут записаны или прочитаны, а количество кусков регулируется уже следующим параметром.
count: как раз то число, которое указывает: сколько кусочков будет скопировано.

Таким образом, описанная команда читает 5*100 мегабайт из устройства /dev/urandom в устройство /dev/null. Придавая этой команде смысловую нагрузку получается, что система сгенерирует 500 мегабайт случайных значений и запишет их в null устройство. Конечно, единственное, что сделает эта команда: нагрузит процессор на несколько секунд. Рассмотрим примеры из практики:

Создание образа диска:

# dd if=/dev/cdrom of=image.iso

Команда будет считывать из устройства данные и записывать в файл до тех пор, пока не достигнет окончания устройства. Если диск битый, можно попробовать его прочитать, игнорируя ошибки чтения:

# dd if=/dev/cdrom of=image.iso conv=noerror

Параметр «conv» позволяет подключать несколько фильтров, применимых к потоку данных. Фильтр «noerror» как раз отключает остановку работы программы, когда наткнется на ошибку чтения. Таким образом, некоторые данные с диска все же можно будет прочитать. Точно таким образом я спас данные со своей флешки Corsair, которую погнули: подобрал подходящее положение, когда контакт есть, и сделал дамп файловой системы.
Подключить, кстати, такие образы можно при помощи команды mount с ключем "-o loop":

# mount -o loop image.iso /mnt/image

Если что-то не получается, процесс разбивается на 2 уровня:

# losetup -e /dev/loop0 image.iso
# mount /dev/loop0 /mnt/image

Если и так не работает, значит файловая система образа полетела.

Работа с носителями информации

Очень простое, хоть и не оптимальное решение клонирования жесткого диска:

# dd if=/dev/sda of=/dev/sdb bs=4096

Все то же побайтовой копирование с размером буфера 4 Кб. Минус способа в том, что при любой заполненности разделов копироваться будут все биты, что не выгодно при копировании разделов с маленькой заполненностью. Чтобы уменьшить время копирования при манипуляции с большими объемами данных, можно просто перенести MBR на новый носитель (я ниже опишу как), перечитать таблицу разделов ядра (при помощи того же fdisk), создать файловые системы и просто скопировать файлы (не забыв сохранить права доступа к файлам).

Как вариант, можно даже по расписанию делать бекап раздела по сети. Разрулив ключи ssh будет работать такая схема:

# dd if=/dev/DEVICE | ssh user@host «dd of=/home/user/DEVICE.img».

Когда-то читал исследование, согласно которому очень большая доля жестких дисков на барахолке подвергается восстановлению данных без привлечения чего-то специализированного, и содержит конфиденциальную информацию. Чтобы на носителе ничего нельзя было восстановить — можно забить его нулями:

# dd if=/dev/zero of=/dev/DEVICE

Думаю, понятно на что нужно заменить DEVICE. После проведения лекций по Linux, я очень тщательно стал следить за тем, что пишу.
Проверить можно тем же dd, но преобразовав данные в hex:

# dd if=/dev/sda | hexdump -C

Должны посыпаться нули.

Операции с MBR

MBR расположена в первых 512 байтах жесткого диска, и состоит из таблицы разделов, загрузчика и пары доп. байт. Иногда, ее приходится бекапить, восстанавливать и т.д. Бекап выполняется так:

# dd if=/dev/sda of=mbr.img bs=512 count=1

Восстановить можно проще:

# dd if=mbr.img of=/dev/sda

Причины этих махинаций с MBR могут быть разные, однако хочу рассказать одну особенность, взятую из опыта: после восстановления давней копии MBR, где один из разделов был ext3, а позже стал FAT и использовался Windows, раздел перестал видиться виндой. Причина — ID раздела, который хранится в MBR. Если UNIX монтирует файловые системы согласно суперблоку, то винды ориентируются на ID разделов из MBR. Поэтому всегда нужно проверять ID разделов при помощи fdisk, особенно если на компьютере есть винды.

Генерация файлов

При помощи dd можно генерировать файлы, а затем использовать их как контейнеры других файловых систем даже в зашифрованном виде. Технология следующая:
При помощи dd создается файл, забитый нулями (случайными числами забивать не рационально: долго и бессмысленно):

# dd if=/dev/zero of=image.crypted bs=1M count=1000

Создался файл размером почти в гигабайт. Теперь нужно сделать этот файл блочным устройством и, при этом, пропустить его через механизм шифрования ядра linux. Я выберу алгоритм blowfish. Подгрузка модулей:

# modprobe cryptoloop
# modprobe blowfish

Ассоциация образа с блочным устройством со включенным шифрованием:

# losetup -e blowfish /dev/loop0 image.crypted

Команда запросит ввести пароль, который и будет ключем к образу. Если ключ введен не правильно, система не смонтируется. Можно будет заново создать данные в образе, используя новый ключ, но к старым данным доступа не будет.
Создаем файловую систему и монтируем:

# mkfs.ext2 /dev/loop0
# mount /dev/loop0 /mnt/image

Образ готов к записи данных. После завершения работы с ним, нужно не забыть его отмонтировать и отключить от блочного loop устройства:

# umount /dev/loop0
# losetup -d /dev/loop0

Теперь шифрованный образ готов.

Синтаксис утилиты достаточно необычен, но в то же время очень прост, после того как вы его запомните и привыкнете:

$ dd if=источник_копирования of=место_назначения параметры

С помощью параметра if вам нужно указать источник, откуда будут копироваться блоки, это может быть устройство, например, /dev/sda или файл - disk.img. Дальше, с помощью параметра of необходимо задать устройство или файл назначения. Другие параметры имеют такой же синтаксис, как if и of.

Теперь давайте рассмотрим дополнительные параметры:

bs - указывает сколько байт читать и записывать за один раз;
cbs - сколько байт нужно записывать за один раз;
count - скопировать указанное количество блоков, размер одного блока указывается в параметре bs;
conv - применить фильтры к потоку данных;
ibs - читать указанное количество байт за раз;
obs - записывать указанное количество байт за раз;
seek - пропустить указанное количество байт в начале устройства для чтения;
skip - пропустить указанное количество байт в начале устройства вывода;
status - указывает насколько подробным нужно сделать вывод;
iflag, oflag - позволяет задать дополнительные флаги работы для устройства ввода и вывода, основные из них: nocache, nofollow.

Обычные пользователи используют команду dd чаще всего для создания образов дисков DVD или CD. Например, чтобы сохранить образ диска в файл можно использовать такую команду:

 sudo dd if=/dev/sr0 of=~/CD.iso bs=2048 conv=noerror


Фильтр noerror позволяет отключить реагирование на ошибки. Дальше, вы можете создать образ жесткого диска или раздела на нем и сохранить этот образ на диск. Только смотрите не сохраните на тот же жесткий диск или раздел, чтобы не вызвать рекурсию:

 dd if=/dev/sda of=~/disk.img
 

В вашей домашней папке будет создан файл с именем disk1.img, который в будущем можно будет развернуть и восстановить испорченную систему. Чтобы записать образ на жесткий диск или раздел достаточно поменять местами адреса устройств:

 dd if=~/disk.img of=/dev/sda

Очень важная и полезная опция - это bs. Она позволяет очень сильно влиять на скорость работы утилиты. Этот параметр позволяет установить размер одного блока при передаче данных. Здесь нужно задать цифровое значение с одним из таких модификаторов формата:

с - один символ;
b - 512 байт;
kB - 1000 байт;
K - 1024 байт;
MB - 1000 килобайт;
M - 1024 килобайт;
GB - 1000 мегабайт;
G - 1024 мегабайт.
Команда dd linux использует именно такую систему, она сложная, но от этого никуда не деться. Ее придется понять и запомнить. Например, 2b - это 1 килобайт, и 1k, это тоже 1 килобайт, 1М - 1 мегабайт. По умолчанию утилита использует размер блока - 512 байт. Например, чтобы ускорить копирование диска можно брать блоки размером по 5 мегабайт. Для этого применяется такая команда:

 dd if=/dev/sda of=~/disk.img bs=5M

Следующий параметр - это count. С помощью него можно указать сколько блоков необходимо скопировать. Например, мы можем создать файл размером 512 мегабайт, заполнив его нулями из /dev/zero или случайными цифрами из /dev/random:

 sudo dd if=/dev/zero of=file.img bs=1M count=512

 Обратите внимание, что этот параметр указывает не размер в мегабайтах, а всего лишь количество блоков. Поэтому, если вы укажите размер блока 1b, то для создания файла размером 1Кб нужно взять только два блока. С помощью этого параметра также можно сделать резервную копию таблицы разделов MBR. Для этого скопируем в файл первые 512 байт жесткого диска:

 sudo dd if=/dev/sda of=mbr.img bs=1b count=1

Для восстановления используйте обычную команду развертывания образа на диск.

Если образ диска слишком большой, можно перенаправить весь вывод нестандартный поток вывода утилиты gzip:

 dd if =/dev/sda2 | bzip2 disk.img.bz2

Также можно использовать утилиту dd linux для копирования файлов, хотя это и не является ее прямым предназначением:

 dd if=/home/sergiy/test.txt of=/home/sergiy/test1.txt

Как вы знаете, команда dd linux пишет данные на диск непосредственно в двоичном виде, это значит, что записываются нули и единицы. Они переопределяют то, что было раньше размещено на устройстве для записи. Поэтому чтобы стереть диск вы можете просто забить его нулями из /dev/zero.

 sudo dd if=/dev/zero of=/dev/sdb

Такое использование dd приводит к тому что весь диск будет полностью стерт.

Выведем обозначение разделов всех устройств
и найдем среди них флеш накопитель:

sudo fdisk -u -l /dev/sd?
Так же, для определения разделов на всех устройства, можно воспользоваться командой:

sudo cat /proc/partitions

Улучшенная версия dd, которая носит название dcfldd.

sudo apt-get install dcfldd

Сотрудники лаборатории DoD Computer Forensics Laboratory (DCFL) внесли некоторые изменения в команду dd, тем самым улучшив ее и применяя в своих исследовательских работах. В итоге на свет появилась команда dcfldd, которая обеспечивает хеширование копируемых данных через некоторые промежутки времени для их аутентификации. Более того, dcfldd работает гораздо быстрее, чем dd. Теперь, если Вы хотите именно видеть прогресс копирования, либо создания образа, Вам нужно выполнить команду:

sudo dcfldd if=/dev/sdc of=image.iso

Создав простой образ командой
dd if=/dev/sdd of=sdd.iso bs=4M conv=noerror,
мы обрекаем себя на хранение файла 4ГБ. А если бы флешка была емкостью 64ГБ? И не одна? Эту проблему нам поможет решить обычный архиватор, возьмем стандартный gzip.


dd if=/dev/sdd bs=4M conv=noerror | gzip -c > sdd.iso.zip


где ключ -c позволяет работать со стандартным выводом.
После завершения работы посмотрим на получившийся файл. ls -al sdd*
Для восстановления флешки из образа используем обратный порядок команд.


gunzip -c sdd.iso.zip | dd of=/dev/sdd conv=noerror bs=4M

sudo dd if=/dev/sdd bs=4M conv=noerror | gzip -c > khadas_load.iso.zip
gunzip -c khadas_load.iso.zip | sudo dd of=/dev/sdd conv=noerror bs=4M

Также можно архивировать образы жестких дисков, где объемы на порядок больше.
Кстати! Для наглядности процесса из-за отсутствия у dd своего прогресс-бара предлагаю использовать небольшую утилитку progress — Coreutils Progress Viewer. Установить её в Fedora не составит труда.
dnf install progress
Для других дистрибутивов нужный репозиторий можно найти по ссылке https://pkgs.org/download/progress.
Установив и запустив утилиту командой watch progress во втором терминале (в первом у нас работает архиватор и dd) от имени того же пользователя, увидим примерно такую картину.
dd образ флешки с архивацией
man progress покажет Вам различные полезные ключи этой утилиты.


dd if=image.iso of=/dev/sdd bs=512

или тоже самое, но уже с отображением прогресса

pv image.iso | dd of=/dev/sdd bs=512


Перед созданием сжатого образа флешки, необходимо залить всё её свободное место нулями:
1) подмонтировать флешку, скажем в /mnt/flash/
2) dd if=/dev/zero of=/mnt/flash/zerofile bs=1M
3) дождаться, пока напишет "No space left on device"
4) sync
5) rm /mnt/flash/zerofile
6) размонтировать флешку
7) делать её образ со сжатием gzip или чем-нибудь ещё


создать образ:
dd if=/dev/sdc1 | gzip -c9 > /PATH/TO/BACKUP.gz

распаковать обратно:
gunzip -c /PATH/TO/BACKUP.gz | dd of=/dev/sdc1