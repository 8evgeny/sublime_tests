############################################################################################
Вместо создания экземпляра класса создаем указатель и затем инициализируем его в нужное время

brightness_adjustment.cpp

#include <logger/logger.h>
#include <settings.h>

#include "brightness_adjustor/brightness_adjustor.h"
#include "modules/module.h"
using namespace runtime;
namespace brightness_adjustment {
class BrightnessAdjustment : public Module {
 public:
  bool Init(std::shared_ptr<const domain::Settings> settings) override {
    ba = std::make_shared<BrightnessAdjustor>(settings);
    return true;
  }
  //  BrightnessAdjustment();
  ModuleResult Run(const hardware::ImagePtr& image,
                   const ModulesData& previous_modules_output) override {
    return ba->Run(image, previous_modules_output);
  }
  bool ApplySettings(const Feedback&) override {
    // TODO replace _thresholds with new values
    return false;
  }
  const std::string& name() const override { return _name; }

 private:
  const std::string _name = "brightness_adjustment";
  std::shared_ptr<BrightnessAdjustor> ba;
};
extern "C" BrightnessAdjustment* Create() { return new BrightnessAdjustment(); }
extern "C" void Destroy(BrightnessAdjustment* m) { delete m; }
}  // namespace brightness_adjustment

строка 29 - вместо создания экземпляра класса создаем указатель на класс !
строка 13 - в методе Init  инициализируем класс - передаем в конструктор settings !

###############################################################################################


sudo LOG_REGIME=console bash -c "../scripts/shooter/run_shooter.sh viewer"
sudo LOG_REGIME=console ./shooter/run_shooter.sh viewer

sudo LOG_REGIME=console bash -c "./gdb_remote_run_shooter.sh viewer"

sudo LOG_REGIME=files ./run_shooter.sh viewer 
(перед скриптом - переменная явным образом)

эта-же переменная в сервисе sudo LOG_REGIME=files ./run_shooter.sh viewer 
[Unit]
Description=shooter
Wants=network-online.target ptpd.service wdkicker.service
After=network.target network-online.target ptpd.service wdkicker.service

[Install]
WantedBy=multi-user.target
[Service]
Environment="LOG_REGIME=files"
Type=simple
Restart=on-failure
RestartSec=20
ExecStart=/usr/bin/bash __SCRIPT_PATH__/run_shooter.sh %i %n
#ExecStop=/usr/bin/pkill -SIGINT shooter


Убрана передача как позиционного параметра
теперь передавать как именной параметр
sudo LOG_REGIME=files LOG_LEVEL=DEBUG ./run_shooter.sh viewer

настройка доступа к postgresql без пароля извне
Допустим, есть комплекс 10.8.1.93
Правим на нем:
sudo mcedit /var/lib/postgres/data/pg_hba.conf
добавить:
host    all             all             0.0.0.0/0               trust
sudo mcedit /var/lib/postgres/data/postgresql.conf
listen_addresses='*'
После этого со своей машины можно выполнять скрипты к базам комплекса напрямую.
например:
psql -U postgres -h 10.8.1.93 -d sadko -c "select count(*) from plates"

развернуть дамп
psql -U postgres -d sadko_93_20210215 -f ./sadko.dump

alias con40='sshpass -p a40-vbersi34 ssh alager@10.99.40.108'

sshfs alager@10.99.40.108:/ /home/eparubets/share/novosib_40/

alias fix_vpn='sudo systemctl restart openfortivpn && sudo systemctl restart openvpn-client@client'



std::string exec(const char* cmd) {
  std::array<char, 128> buffer;
  std::string result;
  std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
  if (!pipe) {
    throw std::runtime_error("popen() failed!");
  }
  while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
    result += buffer.data();
  }
  return result;
}