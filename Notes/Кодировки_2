hexdump  !!

$ iconv option
$ iconv options -f from-encoding -t to-encoding inputfile(s) -o outputfile

Для получения дополнительной информации просмотрите страницу iconv man.
$ man iconv

Чтобы перечислить все известные кодировки символов, выполните следующую команду:
$ iconv -l 

Вы можете проверить кодировку файла с помощью команды file, используя опцию -i или -mime, которая позволяет выводить строку типа mime

$ file -i /etc/sysctl.conf

После запуска команды iconv мы проверяем содержимое выходного файла и новую кодировку символов, как показано ниже.
$ file -i input.file
$ cat input.file
$ iconv -f ISO-8859-1 -t UTF-8//TRANSLIT input.file -o out.file
$ cat out.file
$ file -i out.file
 
Примечание. Если в кодировку добавлена ​​строка //IGNORE, после преобразования отображаются символы, которые не могут быть преобразованы, и ошибка.

Опять же, предположим, что строка //TRANSLIT добавляется в кодировку, как в приведенном выше примере (ASCII//TRANSLIT), преобразуемые символы транслитерируются по мере необходимости. Это подразумевает, что символ не может быть представлен в целевом наборе символов, его можно аппроксимировать одним или несколькими похожими символами.

Преобразование нескольких файлов в кодировку UTF-8
#!/bin/bash
#enter input encoding here
FROM_ENCODING="value_here"
#output encoding(UTF-8)
TO_ENCODING="UTF-8"
#convert
CONVERT=" iconv -f $FROM_ENCODING -t $TO_ENCODING"
#loop to convert multiple files
for file in *.txt; do
$CONVERT "$file" -o "${file%.txt}.utf8.converted"
done
exit 0

$ cat hexdump.txt
linux-faq.ru

Теперь используем команду hexdump без каких-либо параметров для исследования этого файла:

$ hexdump hexdump.txt
0000000 696c 756e 2d78 6166 2e71 7572 000a
000000d

Это используемый по умолчанию, неудобный формат вывода. Очевидно, что в столбце слева приведены 32-битные адреса, а после них следуют шестнадцатеричные представления пар байтов. Эквивалентный результат будет выведен при использовании параметра -x, правда с немного измененным форматированием:

$ hexdump -x hexdump.txt
0000000 696c 756e 2d78 6166 2e71 7572 000a
000000d

Используем параметр -b для исследования файла:

$ hexdump -b hexdump.txt
0000000 154 151 156 165 170 055 146 141 161 056 162 165 012
000000d

В этом формате после шестнадцатеричных значений сдвигов выводятся восьмеричные значения каждого из байтов файла.

Используем параметр -c для исследования файла:

$ hexdump -c hexdump.txt
0000000 l i n u x - f a q . r u n
000000d

В этом формате после шестнадцатеричных значений выводятся непосредственно символы.

Используем параметр -d для исследования файла:

$ hexdump -d hexdump.txt
0000000 26988 30062 11640 24934 11889 30066 00010
000000d

В этом формате после шестнадцатеричных значений сдвигов приводятся десятичные представления пар байтов.

Используем параметр -o для исследования файла:

$ hexdump -o hexdump.txt
0000000 064554 072556 026570 060546 027161 072562 000012
000000d

В этом формате после шестнадцатеричных значений сдвигов приводятся восьмеричные представления пар байтов.

Наконец, используем параметр -C для исследования файла:

$ hexdump -C hexdump.txt
00000000 6c 69 6e 75 78 2d 66 61 71 2e 72 75 0a |linux-faq.ru.|
0000000d

Это классический формат hex-редакторов, который предусматривает вывод шестнадцатеричных значений всех байтов файла с соответствующими им символами.

Примечание: существует команда hd, реализованная в виде символьной ссылки на бинарный файл утилиты hexdump с параметром -C. Ее удобно использовать для исследования бинарных файлов, так как не приходится запоминать необходимый параметр утилиты hexdump.
