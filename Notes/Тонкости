struct похожа на class, но есть два мелких различия:
 - по умолчанию в struct действует видимость public, а в class — private
 - по умолчанию struct наследует члены базовых структур/классов как публичные члены, а class — как приватные члены

 Операция dynamic_cast доступна только в C++ и имеет смысл только, применительно к членам класса иерархии «полиморфных типов». Динамическое приведение типов данных может быть использовано для безопасного приведения указателя (или ссылки) на суперкласс, в указатель (или ссылку) на подкласс в иерархии классов. Если динамическое приведение типов — недопустимо, так как реальный тип объекта, указывает не на тот тип подкласса, приведение типов не выполнится.
 При приведении указателя, в случае неудачи, dynamic_cast возвращает нулевой указатель NULL. Такое поведение обеспечивает быстрый способ определения, является ли данный объект частностью динамического типа.

 Операция const_cast доступна только в C++. Константное приведение используются, чтобы  константную переменную преобразовать в неконстантную.

reinterpret_cast — операция приведения типов данных
Операция reinterpret_cast доступна только в C++ и является наименее безопасной формой приведения типов данных в С++, она позволяет интерпретировать значение в другой тип данных. reinterpret_cast не должна быть использована для приведения иерархии классов или преобразования константных переменных.

reinterpret_cast<dataType>( value );
Рассмотрим пример использования этой операции приведения, например, чтобы преобразовать целое значение в указатель, нужно написать следующее:
reinterpret_cast<int *>(777);

push_back добавляет копию объекта (или обеспечивает перемещение, если возможно), а emplace_back создает объект непосредственно в конце вектора, т.е. без лишнего копирования (или перемещения).

emplace_back стал возможен благодаря появлению variadic templates и forwarding(rvalue-ссылки): это просто отложенный вызов конструктора, который произойдёт в кишках вектора, а не вне его, как это происходит с push_back. В push_back передаётся объект типа T(при условии std::vector<T>), а в emplace_back передаются аргументы из которых T может быть сконструирован. 
emplace_back() позволяет избежать как лишнего копирования так и перемещения: только аргументы передаются. Например, фраза "I am being moved." не печатается в случае emplace_back()