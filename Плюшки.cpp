// переводим все символы в списке в верхний регистр
list<char>::const_iterator pos;
for (pos = coll .begin(); pos ! = coll. end(); ++pos) {
*pos = toupper(*pos);
}

// Если итераторы используются для обхода элементов (неупорядоченных) отображений
// и мультиотображений, то итератор pos ссылается на пары "ключ-значение". Таким образом, выражение
pos->second
// возвращает вторую часть пары "ключ значение", т.е. значение элемента, а выражение
pos->first
// возвращает (константный) ключ.

//Более компактно с auto
for (auto pos coll.begin(); pos 1 = coll.end(); ++pos) {
cout << *pos << ' ';
}
// Однако у такой конструкции есть недостаток - итератор теряет свою константность,
// т.е. появляется риск непреднамеренного присваивания. Выражение
auto pos = coll.begin()
// делает итератор pos неконстантным
// Для того чтобы сохранить константность итератора, в стандарте С++11 предусмотрены
// функции cbegin () и cend (). Они возвращают объект типа контейнер::const iterator.


// type of the collection
    typedef std::set<int> IntSet; //   !!!!!!!! Сокращенное имя
    IntSet coll;        // set container for int values
//    . . . . . код
IntSet::const_iterator pos;
    for (pos = coll.begin(); pos != coll.end(); ++pos) {
        std::cout << *pos << ' ';
    }

// следующая инструкция определяет тип множества,
// в котором элементы упорядочены по убыванию:
typedef set<int,greater<int>> IntSet;
//Объект greater<> - это стандартный функциональный объект

int z = 8<<3;  // z = 64  эквивалентно 8*2^3



