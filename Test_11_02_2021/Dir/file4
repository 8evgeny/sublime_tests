T=intT=int,U=doubleFunctiontemplatesmayonlybefullyspecialized:template<typenameT,typenameU>voidfoo(Tt,Uu){std::cout<<"Generalcase:"<<t<<""<<u<<std::endl;}//OK.template<>voidfoo<int,int>(inta1,inta2){std::cout<<"Twoints:"<<a1<<""<<a2<<std::endl;}voidinvoke_foo(){foo(1,2.1);//Prints"Generalcase:12.1"foo(1,2);//Prints"Twoints:12"}GoalKicker.com–C++NotesforProfessionals419//Compilationerror:partialfunctionspecializationisnotallowed.template<typenameU>voidfoo<std::string,U>(std::stringt,Uu){std::cout<<"Generalcase:"<<t<<""<<u<<std::endl;}Section77.6:TemplateSpecializationYoucandefineimplementationforspecificinstantiationsofatemplateclass/method.Forexampleifyouhave:template<typenameT>Tsqrt(Tt){/*Somegenericimplementation*/}Youcanthenwrite:template<>intsqrt<int>(inti){/*Highlyoptimizedintegerimplementation*/}Thenauserthatwritessqrt(4.0)willgetthegenericimplementationwhereassqrt(4)willgetthespecializedimplementation.Section77.7:AliastemplateVersion≥C++11Basicexample:template<typenameT>usingpointer=T*;Thisdefinitionmakespointer<T>analiasofT*.Forexample:pointer<int>p=newint;//equivalentto:int*p=newint;Aliastemplatescannotbespecialized.However,thatfunctionalitycanbeobtainedindirectlybyhavingthemrefertoanestedtypeinastruct:template<typenameT>structnonconst_pointer_helper{typedefT*type;};template<typenameT>structnonconst_pointer_helper<Tconst>{typedefT*type;};template<typenameT>usingnonconst_pointer=nonconst_pointer_helper<T>::type;Section77.8:ExplicitinstantiationAnexplicitinstantiationdefinitioncreatesanddeclaresaconcreteclass,function,orvariablefromatemplate,withoutusingitjustyet.Anexplicitinstantiationcanbereferencedfromothertranslationunits.Thiscanbeusedtoavoiddefiningatemplateinaheaderfile,ifitwillonlybeinstantiatedwithafinitesetofarguments.Forexample://print_string.htemplate<classT>voidprint_string(constT*str);GoalKicker.com–C++NotesforProfessionals420//print_string.cpp#include"print_string.h"templatevoidprint_string(constchar*);templatevoidprint_string(constwchar_t*);Becauseprint_string<char>andprint_string<wchar_t>areexplicitlyinstantiatedinprint_string.cpp,thelinkerwillbeabletofindthemeventhoughtheprint_stringtemplateisnotdefinedintheheader.Iftheseexplicitinstantiationdeclarationswerenotpresent,alinkererrorwouldlikelyoccur.SeeWhycantemplatesonlybeimplementedintheheaderfile?Version≥C++11Ifanexplicitinstantiationdefinitionisprecededbytheexternkeyword,itbecomesanexplicitinstantiationdeclarationinstead.Thepresenceofanexplicitinstantiationdeclarationforagivenspecializationpreventstheimplicitinstantiationofthegivenspecializationwithinthecurrenttranslationunit.Instead,areferencetothatspecializationthatwouldotherwisecauseanimplicitinstantiationcanrefertoanexplicitinstantiationdefinitioninthesameoranotherTU.foo.h#ifndefFOO_H#defineFOO_Htemplate<classT>voidfoo(Tx){//complicatedimplementation}#endiffoo.cpp#include"foo.h"//explicitinstantiationdefinitionsforcommoncasestemplatevoidfoo(int);templatevoidfoo(double);main.cpp#include"foo.h"//wealreadyknowfoo.cpphasexplicitinstantiationdefinitionsfortheseexterntemplatevoidfoo(double);intmain(){foo(42);//instantiatesfoo<int>here;//wastefulsincefoo.cppprovidesanexplicitinstantiationalready!foo(3.14);//doesnotinstantiatefoo<double>here;//usesinstantiationoffoo<double>infoo.cppinstead}Section77.9:Non-typetemplateparameterApartfromtypesasatemplateparameterweareallowedtodeclarevaluesofconstantexpressionsmeetingoneofthefollowingcriteria:integralorenumerationtype,pointertoobjectorpointertofunction,lvaluereferencetoobjectorlvaluereferencetofunction,pointertomember,std::nullptr_t.GoalKicker.com–C++NotesforProfessionals421Likealltemplateparameters,non-typetemplateparameterscanbeexplicitlyspecified,defaulted,orderivedimplicitlyviaTemplateArgumentDeduction.Exampleofnon-typetemplateparameterusage:#include<iostream>template<typenameT,std::size_tsize>std::size_tsize_of(T(&anArray)[size])//Passarraybyreference.Requires.{//anexactsize.Weallowallsizesreturnsize;//byusingatemplate"size".}intmain(){charanArrayOfChar[15];std::cout<<"anArrayOfChar:"<<size_of(anArrayOfChar)<<"\n";}intanArrayOfData[]={1,2,3,4,5,6,7,8,9};std::cout<<"anArrayOfData:"<<size_of(anArrayOfData)<<"\n";Exampleofexplicitlyspecifyingbothtypeandnon-typetemplateparameters:#include<array>intmain(){std::array<int,5>foo;//intisatypeparameter,5isnon-type}Non-typetemplateparametersareoneofthewaystoachievetemplaterecurrenceandenablestodoMetaprogramming.Section77.10:Declaringnon-typetemplateargumentswithautoPriortoC++17,whenwritingatemplatenon-typeparameter,youhadtospecifyitstypefirst.Soacommonpatternbecamewritingsomethinglike:template<classT,TN>structintegral_constant{usingtype=T;staticconstexprTvalue=N;};usingfive=integral_constant<int,5>;Butforcomplicatedexpressions,usingsomethinglikethisinvolveshavingtowritedecltype(expr),exprwheninstantiatingtemplates.Thesolutionistosimplifythisidiomandsimplyallowauto:Version≥C++17template<autoN>structintegral_constant{usingtype=decltype(N);staticconstexprtypevalue=N;};GoalKicker.com–C++NotesforProfessionals422usingfive=integral_constant<5>;Emptycustomdeleterforunique_ptrAnicemotivatingexamplecancomefromtryingtocombinetheemptybaseoptimizationwithacustomdeleterforunique_ptr.DifferentCAPIdeletershavedifferentreturntypes,butwedon'tcare-wejustwantsomethingtoworkforanyfunction:template<autoDeleteFn>structFunctionDeleter{template<classT>voidoperator()(T*ptr)const{DeleteFn(ptr);}};template<T,autoDeleteFn>usingunique_ptr_deleter=std::unique_ptr<T,FunctionDeleter<DeleteFn>>;AndnowyoucansimplyuseanyfunctionpointerthatcantakeanargumentoftypeTasatemplatenon-typeparameter,regardlessofreturntype,andgetano-sizeoverheadunique_ptroutofit:unique_ptr_deleter<std::FILE,std::fclose>p;Section77.11:TemplatetemplateparametersSometimeswewouldliketopassintothetemplateatemplatetypewithoutfixingitsvalues.Thisiswhattemplatetemplateparametersarecreatedfor.Verysimpletemplatetemplateparameterexamples:template<classT>structTag1{};template<classT>structTag2{};template<template<class>classTag>structIntTag{typedefTag<int>type;};intmain(){IntTag<Tag1>::typet;}Version≥C++11#include<vector>#include<iostream>template<classT,template<class...>classC,classU>C<T>cast_all(constC<U>&c){C<T>result(c.begin(),c.end());returnresult;}intmain(){std::vector<float>vf={1.2,2.6,3.7};autovi=cast_all<int>(vf);for(auto&&i:vi){std::cout<<i<<std::endl;}GoalKicker.com–C++NotesforProfessionals423}Section77.12:DefaulttemplateparametervalueJustlikeincaseofthefunctionarguments,templateparameterscanhavetheirdefaultvalues.Alltemplateparameterswithadefaultvaluehavetobedeclaredattheendofthetemplateparameterlist.Thebasicideaisthatthetemplateparameterswithdefaultvaluecanbeomittedwhiletemplateinstantiation.Simpleexampleofdefaulttemplateparametervalueusage:template<classT,size_tN=10>structmy_array{Tarr[N];};intmain(){/*Defaultparameterisignored,N=5*/my_array<int,5>a;}/*Printthelengthofa.arr:5*/std::cout<<sizeof(a.arr)/sizeof(int)<<std::endl;/*Lastparameterisomitted,N=10*/my_array<int>b;/*Printthelengthofa.arr:10*/std::cout<<sizeof(b.arr)/sizeof(int)<<std::endl;GoalKicker.com–C++NotesforProfessionals424Chapter78:ExpressiontemplatesSection78.1:AbasicexampleillustratingexpressiontemplatesAnexpressiontemplateisacompile-timeoptimizationtechniqueusedmostlyinscientificcomputing.It'smainpurposeistoavoidunnecessarytemporariesandoptimizeloopcalculationsusingasinglepass(typicallywhenperformingoperationsonnumericalaggregates).ExpressiontemplateswereinitiallydevisedinordertocircumventtheinefficienciesofnaïveoperatoroverloadingwhenimplementingnumericalArrayorMatrixtypes.AnequivalentterminologyforexpressiontemplateshasbeenintroducedbyBjarneStroustrup,whocallsthem"fusedoperations"inthelatestversionofhisbook,"TheC++ProgrammingLanguage".Beforeactuallydivingintoexpressiontemplates,youshouldunderstandwhyyouneedtheminthefirstplace.Toillustratethis,considertheverysimpleMatrixclassgivenbelow:template<typenameT,std::size_tCOL,std::size_tROW>classMatrix{public:usingvalue_type=T;Matrix():values(COL*ROW){}staticsize_tcols(){returnCOL;}staticsize_trows(){returnROW;}constT&operator()(size_tx,size_ty)const{returnvalues[y*COL+x];}T&operator()(size_tx,size_ty){returnvalues[y*COL+x];}private:std::vector<T>};values;template<typenameT,std::size_tCOL,std::size_tROW>Matrix<T,COL,ROW>operator+(constMatrix<T,COL,ROW>&lhs,constMatrix<T,COL,ROW>&rhs){Matrix<T,COL,ROW>result;}for(size_ty=0;y!=lhs.rows();++y){for(size_tx=0;x!=lhs.cols();++x){result(x,y)=lhs(x,y)+rhs(x,y);}}returnresult;Giventhepreviousclassdefinition,youcannowwriteMatrixexpressionssuchas:conststd::size_tcols=2000;conststd::size_trows=1000;Matrix<double,cols,rows>a,b,c;//initializea,b&cfor(std::size_ty=0;y!=rows;++y){for(std::size_tx=0;x!=cols;++x){a(x,y)=1.0;b(x,y)=2.0;GoalKicker.com–C++NotesforProfessionals425}}c(x,y)=3.0;Matrix<double,cols,rows>d=a+b+c;//d(x,y)=6Asillustratedabove,beingabletooverloadoperator+()providesyouwithanotationwhichmimicsthenaturalmathematicalnotationformatrices.Unfortunately,thepreviousimplementationisalsohighlyinefficientcomparedtoanequivalent"hand-crafted"version.Tounderstandwhy,youhavetoconsiderwhathappenswhenyouwriteanexpressionsuchasMatrixd=a+b+c.Thisinfactexpandsto((a+b)+c)oroperator+(operator+(a,b),c).Inotherwords,theloopinsideoperator+()isexecutedtwice,whereasitcouldhavebeeneasilyperformedinasinglepass.Thisalsoresultsin2temporariesbeingcreated,whichfurtherdegradesperformance.Inessence,byaddingtheflexibilitytouseanotationclosetoitsmathematicalcounterpart,youhavealsomadetheMatrixclasshighlyinefficient.Forexample,withoutoperatoroverloading,youcouldimplementafarmoreefficientMatrixsummationusingasinglepass:template<typenameT,std::size_tCOL,std::size_tROW>Matrix<T,COL,ROW>add3(constMatrix<T,COL,ROW>&a,constMatrix<T,COL,ROW>&b,constMatrix<T,COL,ROW>&c){Matrix<T,COL,ROW>result;for(size_ty=0;y!=ROW;++y){for(size_tx=0;x!=COL;++x){result(x,y)=a(x,y)+b(x,y)+c(x,y);}}returnresult;}ThepreviousexamplehoweverhasitsowndisadvantagesbecauseitcreatesafarmoreconvolutedinterfacefortheMatrixclass(youwouldhavetoconsidermethodssuchasMatrix::add2(),Matrix::AddMultiply()andsoon).InsteadletustakeastepbackandseehowwecanadaptoperatoroverloadingtoperforminamoreefficientwayTheproblemstemsfromthefactthattheexpressionMatrixd=a+b+cisevaluatedtoo"eagerly"beforeyouhavehadanopportunitytobuildtheentireexpressiontree.Inotherwords,whatyoureallywanttoachieveistoevaluatea+b+cinonepassandonlyonceyouactuallyneedtoassigntheresultingexpressingtod.Thisisthecoreideabehindexpressiontemplates:insteadofhavingoperator+()evaluateimmediatelytheresultofaddingtwoMatrixinstances,itwillreturnan"expressiontemplate"forfutureevaluationoncetheentireexpressiontreehasbeenbuilt.Forexample,hereisapossibleimplementationforanexpressiontemplatecorrespondingtothesummationof2types:template<typenameLHS,typenameRHS>classMatrixSum{public:usingvalue_type=typenameLHS::value_type;GoalKicker.com–C++NotesforProfessionals426MatrixSum(constLHS&lhs,constRHS&rhs):rhs(rhs),lhs(lhs){}value_typeoperator()(intx,inty)const{returnlhs(x,y)+rhs(x,y);}private:constLHS&lhs;constRHS&rhs;};Andhereistheupdatedversionofoperator+()template<typenameLHS,typenameRHS>MatrixSum<LHS,RHS>operator+(constLHS&lhs,constLHS&rhs){returnMatrixSum<LHS,RHS>(lhs,rhs);}Asyoucansee,operator+()nolongerreturnsan"eagerevaluation"oftheresultofadding2Matrixinstances(whichwouldbeanotherMatrixinstance),butinsteadanexpressiontemplaterepresentingtheadditionoperation.Themostimportantpointtokeepinmindisthattheexpressionhasnotbeenevaluatedyet.Itmerelyholdsreferencestoitsoperands.Infact,nothingstopsyoufrominstantiatingtheMatrixSum<>expressiontemplateasfollows:MatrixSum<Matrix<double>,Matrix<double>>SumAB(a,b);Youcanhoweveratalaterstage,whenyouactuallyneedtheresultofthesummation,evaluatetheexpressiond=a+basfollows:for(std::size_ty=0;y!=a.rows();++y){for(std::size_tx=0;x!=a.cols();++x){d(x,y)=SumAB(x,y);}}Asyoucansee,anotherbenefitofusinganexpressiontemplate,isthatyouhavebasicallymanagedtoevaluatethesumofaandbandassignittodinasinglepas
,
=
_
pla
.
lo
