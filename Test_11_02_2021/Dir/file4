T=intT=int,U=doubleFunctiontemplatesmayonlybefullyspecialized:template<typenameT,typenameU>voidfoo(Tt,Uu){std::cout<<"Generalcase:"<<t<<""<<u<<std::endl;}//OK.template<>voidfoo<int,int>(inta1,inta2){std::cout<<"Twoints:"<<a1<<""<<a2<<std::endl;}voidinvoke_foo(){foo(1,2.1);//Prints"Generalcase:12.1"foo(1,2);//Prints"Twoints:12"}GoalKicker.com–C++NotesforProfessionals419//Compilationerror:partialfunctionspecializationisnotallowed.template<typenameU>voidfoo<std::string,U>(std::stringt,Uu){std::cout<<"Generalcase:"<<t<<""<<u<<std::endl;}Section77.6:TemplateSpecializationYoucandefineimplementationforspecificinstantiationsofatemplateclass/method.Forexampleifyouhave:template<typenameT>Tsqrt(Tt){/*Somegenericimplementation*/}Youcanthenwrite:template<>intsqrt<int>(inti){/*Highlyoptimizedintegerimplementation*/}Thenauserthatwritessqrt(4.0)willgetthegenericimplementationwhereassqrt(4)willgetthespecializedimplementation.Section77.7:AliastemplateVersion≥C++11Basicexample:template<typenameT>usingpointer=T*;Thisdefinitionmakespointer<T>analiasofT*.Forexample:pointer<int>p=newint;//equivalentto:int*p=newint;Aliastemplatescannotbespecialized.However,thatfunctionalitycanbeobtainedindirectlybyhavingthemrefertoanestedtypeinastruct:template<typenameT>structnonconst_pointer_helper{typedefT*type;};template<typenameT>structnonconst_pointer_helper<Tconst>{typedefT*type;};template<typenameT>usingnonconst_pointer=nonconst_pointer_helper<T>::type;Section77.8:ExplicitinstantiationAnexplicitinstantiationdefinitioncreatesanddeclaresaconcreteclass,function,orvariablefromatemplate,withoutusingitjustyet.Anexplicitinstantiationcanbereferencedfromothertranslationunits.Thiscanbeusedtoavoiddefiningatemplateinaheaderfile,ifitwillonlybeinstantiatedwithafinitesetofarguments.Forexample://print_string.htemplate<classT>voidprint_string(constT*str);GoalKicker.com–C++NotesforProfessionals420//print_string.cpp#include"print_string.h"templatevoidprint_string(constchar*);templatevoidprint_string(constwchar_t*);Becauseprint_string<char>andprint_string<wchar_t>areexplicitlyinstantiatedinprint_string.cpp,thelinkerwillbeabletofindthemeventhoughtheprint_stringtemplateisnotdefinedintheheader.Iftheseexplicitinstantiationdeclarationswerenotpresent,alinkererrorwouldlikelyoccur.SeeWhycantemplatesonlybeimplementedintheheaderfile?Version≥C++11Ifanexplicitinstantiationdefinitionisprecededbytheexternkeyword,itbecomesanexplicitinstantiationdeclarationinstead.Thepresenceofanexplicitinstantiationdeclarationforagivenspecializationpreventstheimplicitinstantiationofthegivenspecializationwithinthecurrenttranslationunit.Instead,areferencetothatspecializationthatwouldotherwisecauseanimplicitinstantiationcanrefertoanexplicitinstantiationdefinitioninthesameoranotherTU.foo.h#ifndefFOO_H#defineFOO_Htemplate<classT>voidfoo(Tx){//complicatedimplementation}#endiffoo.cpp#include"foo.h"//explicitinstantiationdefinitionsforcommoncasestemplatevoidfoo(int);templatevoidfoo(double);main.cpp#include"foo.h"//wealreadyknowfoo.cpphasexplicitinstantiationdefinitionsfortheseexterntemplatevoidfoo(double);intmain(){foo(42);//instantiatesfoo<int>here;//wastefulsincefoo.cppprovidesanexplicitinstantiationalready!foo(3.14);//doesnotinstantiatefoo<double>here;//usesinstantiationoffoo<double>infoo.cppinstead}Section77.9:Non-typetemplateparameterApartfromtypesasatemplateparameterweareallowedtodeclarevaluesofconstantexpressionsmeetingoneofthefollowingcriteria:integralorenumerationtype,pointertoobjectorpointertofunction,lvaluereferencetoobjectorlvaluereferencetofunction,pointertomember,std::nullptr_t.GoalKicker.com–C++NotesforProfessionals421Likealltemplateparameters,non-typetemplateparameterscanbeexplicitlyspecified,defaulted,orderivedimplicitlyviaTemplateArgumentDeduction.Exampleofnon-typetemplateparameterusage:#include<iostream>template<typenameT,std::size_tsize>std::size_tsize_of(T(&anArray)[size])//Passarraybyreference.Requires.{//anexactsize.Weallowallsizesreturnsize;//byusingatemplate"size".}intmain(){charanArrayOfChar[15];std::cout<<"anArrayOfChar:"<<size_of(anArrayOfChar)<<"\n";}intanArrayOfData[]={1,2,3,4,5,6,7,8,9};std::cout<<"anArrayOfData:"<<size_of(anArrayOfData)<<"\n";Exampleofexplicitlyspecifyingbothtypeandnon-typetemplateparameters:#include<array>intmain(){std::array<int,5>foo;//intisatypeparameter,5isnon-type}Non-typetemplateparametersareoneofthewaystoachievetemplaterecurrenceandenablestodoMetaprogramming.Section77.10:Declaringnon-typetemplateargumentswithautoPriortoC++17,whenwritingatemplatenon-typeparameter,youhadtospecifyitstypefirst.Soacommonpatternbecamewritingsomethinglike:template<classT,TN>structintegral_constant{usingtype=T;staticconstexprTvalue=N;};usingfive=integral_constant<int,5>;Butforcomplicatedexpressions,usingsomethinglikethisinvolveshavingtowritedecltype(expr),exprwheninstantiatingtemplates.Thesolutionistosimplifythisidiomandsimplyallowauto:Version≥C++17template<autoN>structintegral_constant{usingtype=decltype(N);staticconstexprtypevalue=N;};GoalKicker.com–C++NotesforProfessionals422usingfive=integral_constant<5>;Emptycustomdeleterforunique_ptrAnicemotivatingexamplecancomefromtryingtocombinetheemptybaseoptimizationwithacustomdeleterforunique_ptr.DifferentCAPIdeletershavedifferentreturntypes,butwedon'tcare-wejustwantsomethingtoworkforanyfunction:template<autoDeleteFn>structFunctionDeleter{template<classT>voidoperator()(T*ptr)const{DeleteFn(ptr);}};template<T,autoDeleteFn>usingunique_ptr_deleter=std::unique_ptr<T,FunctionDeleter<DeleteFn>>;AndnowyoucansimplyuseanyfunctionpointerthatcantakeanargumentoftypeTasatemplatenon-typeparameter,regardlessofreturntype,andgetano-sizeoverheadunique_ptroutofit:unique_ptr_deleter<std::FILE,std::fclose>p;Section77.11:TemplatetemplateparametersSometimeswewouldliketopassintothetemplateatemplatetypewithoutfixingitsvalues.Thisiswhattemplatetemplateparametersarecreatedfor.Verysimpletemplatetemplateparameterexamples:template<classT>structTag1{};template<classT>structTag2{};template<template<class>classTag>structIntTag{typedefTag<int>type;};intmain(){IntTag<Tag1>::typet;}Version≥C++11#include<vector>#include<iostream>template<classT,template<class...>classC,classU>C<T>cast_all(constC<U>&c){C<T>result(c.begin(),c.end());returnresult;}intmain(){std::vector<float>vf={1.2,2.6,3.7};autovi=cast_all<int>(vf);for(auto&&i:vi){std::cout<<i<<std::endl;}GoalKicker.com–C++NotesforProfessix::pas
,
=
_
pla
.
lo
