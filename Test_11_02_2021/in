T = int
T = int, U = double
Function templates may only be fully specialized:
template<typename T, typename U>
void foo(T t, U u) {
std::cout << "General case: " << t << " " << u << std::endl;
}
// OK.
template<>
void foo<int, int>(int a1, int a2) {
std::cout << "Two ints: " << a1 << " " << a2 << std::endl;
}
void invoke_foo() {
foo(1, 2.1); // Prints "General case: 1 2.1"
foo(1,2);
 // Prints "Two ints: 1 2"
}
GoalKicker.com – C++ Notes for Professionals
 419
// Compilation error: partial function specialization is not allowed.
template<typename U>
void foo<std::string, U>(std::string t, U u) {
std::cout << "General case: " << t << " " << u << std::endl;
}
Section 77.6: Template Specialization
You can define implementation for specific instantiations of a template class/method.
For example if you have:
template <typename T>
T sqrt(T t) { /* Some generic implementation */ }
You can then write:
template<>
int sqrt<int>(int i) { /* Highly optimized integer implementation */ }
Then a user that writes sqrt(4.0) will get the generic implementation whereas sqrt(4) will get the specialized
implementation.
Section 77.7: Alias template
Version ≥ C++11
Basic example:
template<typename T> using pointer = T*;
This definition makes pointer<T> an alias of T*. For example:
pointer<int> p = new int; // equivalent to: int* p = new int;
Alias templates cannot be specialized. However, that functionality can be obtained indirectly by having them refer
to a nested type in a struct:
template<typename T>
struct nonconst_pointer_helper { typedef T* type; };
template<typename T>
struct nonconst_pointer_helper<T const> { typedef T* type; };
template<typename T> using nonconst_pointer = nonconst_pointer_helper<T>::type;
Section 77.8: Explicit instantiation
An explicit instantiation definition creates and declares a concrete class, function, or variable from a template,
without using it just yet. An explicit instantiation can be referenced from other translation units. This can be used to
avoid defining a template in a header file, if it will only be instantiated with a finite set of arguments. For example:
// print_string.h
template <class T>
void print_string(const T* str);
GoalKicker.com – C++ Notes for Professionals
 420
// print_string.cpp
#include "print_string.h"
template void print_string(const char*);
template void print_string(const wchar_t*);
Because print_string<char> and print_string<wchar_t> are explicitly instantiated in print_string.cpp, the
linker will be able to find them even though the print_string template is not defined in the header. If these explicit
instantiation declarations were not present, a linker error would likely occur. See Why can templates only be
implemented in the header file?
Version ≥ C++11
If an explicit instantiation definition is preceded by the extern keyword, it becomes an explicit instantiation
declaration instead. The presence of an explicit instantiation declaration for a given specialization prevents the
implicit instantiation of the given specialization within the current translation unit. Instead, a reference to that
specialization that would otherwise cause an implicit instantiation can refer to an explicit instantiation definition in
the same or another TU.
foo.h
#ifndef FOO_H
#define FOO_H
template <class T> void foo(T x) {
// complicated implementation
}
#endif
foo.cpp
#include "foo.h"
// explicit instantiation definitions for common cases
template void foo(int);
template void foo(double);
main.cpp
#include "foo.h"
// we already know foo.cpp has explicit instantiation definitions for these
extern template void foo(double);
int main() {
foo(42);
 // instantiates foo<int> here;
// wasteful since foo.cpp provides an explicit instantiation already!
foo(3.14); // does not instantiate foo<double> here;
// uses instantiation of foo<double> in foo.cpp instead
}
Section 77.9: Non-type template parameter
Apart from types as a template parameter we are allowed to declare values of constant expressions meeting one of
the following criteria:
integral or enumeration type,
pointer to object or pointer to function,
lvalue reference to object or lvalue reference to function,
pointer to member,
std::nullptr_t.
GoalKicker.com – C++ Notes for Professionals
 421
Like all template parameters, non-type template parameters can be explicitly specified, defaulted, or derived
implicitly via Template Argument Deduction.
Example of non-type template parameter usage:
#include <iostream>
template<typename T, std::size_t size>
std::size_t size_of(T (&anArray)[size])
 // Pass array by reference. Requires.
{
 // an exact size. We allow all sizes
return size;
 // by using a template "size".
}
int main()
{
char anArrayOfChar[15];
std::cout << "anArrayOfChar: " << size_of(anArrayOfChar) << "\n";
}
int anArrayOfData[] = {1,2,3,4,5,6,7,8,9};
std::cout << "anArrayOfData: " << size_of(anArrayOfData) << "\n";
Example of explicitly specifying both type and non-type template parameters:
#include <array>
int main ()
{
std::array<int, 5> foo; // int is a type parameter, 5 is non-type
}
Non-type template parameters are one of the ways to achieve template recurrence and enables to do
Metaprogramming.
Section 77.10: Declaring non-type template arguments with
auto
Prior to C++17, when writing a template non-type parameter, you had to specify its type first. So a common pattern
became writing something like:
template <class T, T N>
struct integral_constant {
using type = T;
static constexpr T value = N;
};
using five = integral_constant<int, 5>;
But for complicated expressions, using something like this involves having to write decltype(expr), expr when
instantiating templates. The solution is to simplify this idiom and simply allow auto:
Version ≥ C++17
template <auto N>
struct integral_constant {
using type = decltype(N);
static constexpr type value = N;
};
GoalKicker.com – C++ Notes for Professionals
 422
using five = integral_constant<5>;
Empty custom deleter for unique_ptr
A nice motivating example can come from trying to combine the empty base optimization with a custom deleter for
unique_ptr. Different C API deleters have different return types, but we don't care - we just want something to
work for any function:
template <auto DeleteFn>
struct FunctionDeleter {
template <class T>
void operator()(T* ptr) const {
DeleteFn(ptr);
}
};
template <T, auto DeleteFn>
using unique_ptr_deleter = std::unique_ptr<T, FunctionDeleter<DeleteFn>>;
And now you can simply use any function pointer that can take an argument of type T as a template non-type
parameter, regardless of return type, and get a no-size overhead unique_ptr out of it:
unique_ptr_deleter<std::FILE, std::fclose> p;
Section 77.11: Template template parameters
Sometimes we would like to pass into the template a template type without fixing its values. This is what template
template parameters are created for. Very simple template template parameter examples:
template <class T>
struct Tag1 { };
template <class T>
struct Tag2 { };
template <template <class> class Tag>
struct IntTag {
typedef Tag<int> type;
};
int main() {
IntTag<Tag1>::type t;
}
Version ≥ C++11
#include <vector>
#include <iostream>
template <class T, template <class...> class C, class U>
C<T> cast_all(const C<U> &c) {
C<T> result(c.begin(), c.end());
return result;
}
int main() {
std::vector<float> vf = {1.2, 2.6, 3.7};
auto vi = cast_all<int>(vf);
for(auto &&i: vi) {
std::cout << i << std::endl;
}
GoalKicker.com – C++ Notes for Professionals
423
}
Section 77.12: Default template parameter value
Just like in case of the function arguments, template parameters can have their default values. All template
parameters with a default value have to be declared at the end of the template parameter list. The basic idea is that
the template parameters with default value can be omitted while template instantiation.
Simple example of default template parameter value usage:
template <class T, size_t N = 10>
struct my_array {
T arr[N];
};
int main() {
/* Default parameter is ignored, N = 5 */
my_array<int, 5> a;
}
/* Print the length of a.arr: 5 */
std::cout << sizeof(a.arr) / sizeof(int) << std::endl;
/* Last parameter is omitted, N = 10 */
my_array<int> b;
/* Print the length of a.arr: 10 */
std::cout << sizeof(b.arr) / sizeof(int) << std::endl;
GoalKicker.com – C++ Notes for Professionals
 424
Chapter 78: Expression templates
Section 78.1: A basic example illustrating expression
templates
An expression template is a compile-time optimization technique used mostly in scientific computing. It's main
purpose is to avoid unnecessary temporaries and optimize loop calculations using a single pass (typically when
performing operations on numerical aggregates). Expression templates were initially devised in order to circumvent
the inefficiencies of naïve operator overloading when implementing numerical Array or Matrix types. An equivalent
terminology for expression templates has been introduced by Bjarne Stroustrup, who calls them "fused operations"
in the latest version of his book, "The C++ Programming Language".
Before actually diving into expression templates, you should understand why you need them in the first place. To
illustrate this, consider the very simple Matrix class given below:
template <typename T, std::size_t COL, std::size_t ROW>
class Matrix {
public:
using value_type = T;
Matrix() : values(COL * ROW) {}
static size_t cols() { return COL; }
static size_t rows() { return ROW; }
const T& operator()(size_t x, size_t y) const { return values[y * COL + x]; }
T& operator()(size_t x, size_t y) { return values[y * COL + x]; }
private:
std::vector<T>};
values;
template <typename T, std::size_t COL, std::size_t ROW>
Matrix<T, COL, ROW>
operator+(const Matrix<T, COL, ROW>& lhs, const Matrix<T, COL, ROW>& rhs)
{
Matrix<T, COL, ROW> result;
}
for (size_t y = 0; y != lhs.rows(); ++y) {
for (size_t x = 0; x != lhs.cols(); ++x) {
result(x, y) = lhs(x, y) + rhs(x, y);
}
}
return result;
Given the previous class definition, you can now write Matrix expressions such as:
const std::size_t cols = 2000;
const std::size_t rows = 1000;
Matrix<double, cols, rows> a, b, c;
// initialize a, b & c
for (std::size_t y = 0; y != rows; ++y) {
for (std::size_t x = 0; x != cols; ++x) {
a(x, y) = 1.0;
b(x, y) = 2.0;
GoalKicker.com – C++ Notes for Professionals
425
}
}
c(x, y) = 3.0;
Matrix<double, cols, rows> d = a + b + c;
 // d(x, y) = 6
As illustrated above, being able to overload operator+() provides you with a notation which mimics the natural
mathematical notation for matrices.
Unfortunately, the previous implementation is also highly inefficient compared to an equivalent "hand-crafted"
version.
To understand why, you have to consider what happens when you write an expression such as Matrix d = a + b
+ c. This in fact expands to ((a + b) + c) or operator+(operator+(a, b), c). In other words, the loop inside
operator+() is executed twice, whereas it could have been easily performed in a single pass. This also results in 2
temporaries being created, which further degrades performance. In essence, by adding the flexibility to use a
notation close to its mathematical counterpart, you have also made the Matrix class highly inefficient.
For example, without operator overloading, you could implement a far more efficient Matrix summation using a
single pass:
template<typename T, std::size_t COL, std::size_t ROW>
Matrix<T, COL, ROW> add3(const Matrix<T, COL, ROW>& a,
const Matrix<T, COL, ROW>& b,
const Matrix<T, COL, ROW>& c)
{
Matrix<T, COL, ROW> result;
for (size_t y = 0; y != ROW; ++y) {
for (size_t x = 0; x != COL; ++x) {
result(x, y) = a(x, y) + b(x, y) + c(x, y);
}
}
return result;
}
The previous example however has its own disadvantages because it creates a far more convoluted interface for
the Matrix class (you would have to consider methods such as Matrix::add2(), Matrix::AddMultiply() and so
on).
Instead let us take a step back and see how we can adapt operator overloading to perform in a more efficient way
The problem stems from the fact that the expression Matrix d = a + b + c is evaluated too "eagerly" before you
have had an opportunity to build the entire expression tree. In other words, what you really want to achieve is to
evaluate a + b + c in one pass and only once you actually need to assign the resulting expressing to d.
This is the core idea behind expression templates: instead of having operator+() evaluate immediately the result
of adding two Matrix instances, it will return an "expression template" for future evaluation once the entire
expression tree has been built.
For example, here is a possible implementation for an expression template corresponding to the summation of 2
types:
template <typename LHS, typename RHS>
class MatrixSum
{
public:
using value_type = typename LHS::value_type;
GoalKicker.com – C++ Notes for Professionals
426
MatrixSum(const LHS& lhs, const RHS& rhs) : rhs(rhs), lhs(lhs) {}
value_type
 operator() (int x, int y) const
 {
return
 lhs(x, y) + rhs(x, y);
}
private:
const LHS&
 lhs;
const RHS&
 rhs;
};
And here is the updated version of operator+()
template <typename LHS, typename RHS>
MatrixSum<LHS, RHS> operator+(const LHS& lhs, const LHS& rhs) {
return MatrixSum<LHS, RHS>(lhs, rhs);
}
As you can see, operator+() no longer returns an "eager evaluation" of the result of adding 2 Matrix instances
(which would be another Matrix instance), but instead an expression template representing the addition operation.
The most important point to keep in mind is that the expression has not been evaluated yet. It merely holds
references to its operands.
In fact, nothing stops you from instantiating the MatrixSum<> expression template as follows:
MatrixSum<Matrix<double>, Matrix<double> > SumAB(a, b);
You can however at a later stage, when you actually need the result of the summation, evaluate the expression d =
a + b as follows:
for (std::size_t y = 0; y != a.rows(); ++y) {
for (std::size_t x = 0; x != a.cols(); ++x) {
d(x, y) = SumAB(x, y);
}
}
As you can see, another benefit of using an expression template, is that you have basically managed to evaluate the
sum of a and b and assign it to d in a single pass.
